interface Array<T> {
    /**数组反转 */
    each(predict: (item: T, i: number, array: T[]) => boolean | void): void;
    eachAsync(predict: (item: T, i: number, array: T[]) => Promise<void | boolean>): Promise<void>;
    eachReverse(predict: (item: T, i: number, array: T[]) => boolean | void): void;
    findLast(predict: T | ((item: T, i: number, array: any[]) => boolean)): T;
    find(predict: T | ((item: T, i: number, array: T[]) => boolean)): T;
    findAll(predict: T | ((item: T, i: number, array: T[]) => boolean)): T[];
    findBefore(pos: T | number | ((item: T, i?: number, array?: T[]) => boolean), predict: T | ((item: T, i?: number, array?: T[]) => boolean), isIncludeSelf?: boolean): T;
    findAllBefore(pos: T | number | ((item: T, i?: number, array?: T[]) => boolean), predict: T | ((item: T, i?: number, array?: T[]) => boolean), isIncludeSelf?: boolean): T[];
    findAfter(pos: T | number | ((item: T, i?: number, array?: T[]) => boolean), predict: T | ((item: T, i?: number, array?: T[]) => boolean), isIncludeSelf?: boolean): T;
    findAllAfter(pos: T | number | ((item: T, i?: number, array?: T[]) => boolean), predict: T | ((item: T, i?: number, array?: T[]) => boolean), isIncludeSelf?: boolean): T[];
    remove(predict: T | ((item: T, i?: number, array?: T[]) => boolean)): void;
    removeLast(predict: T | ((item: T, i?: number, array?: T[]) => boolean)): void;
    delete(predict: T | ((item: T, i?: number, array?: T[]) => boolean)): void;
    removeAt(index: number): void;
    removeAll(predict: T | ((item: T, i?: number, array?: T[]) => boolean)): void;
    deleteAll(predict: T | ((item: T, i?: number, array?: T[]) => boolean)): void;
    exists(predict: T | ((item: T, i: number, array: T[]) => boolean)): boolean;
    notExistsAppend(item: T, predict: any | ((item: T, i?: number, array?: T[]) => boolean)): void;
    trueForAll(predict: T | ((item: T, i?: number, array?: T[]) => boolean)): boolean;
    existsReplace(exists: T | ((item: T, i?: number, array?: T[]) => boolean), item: T): boolean;
    existsReplaceElseAppend(exists: T | ((item: T, i?: number, array?: T[]) => boolean), item: T): boolean;
    first(item?: T): T;
    last(item?: T): T;
    eq(pos: number): T;
    firstOrDefault(): T;
    replace(predict: number | T | ((item: T, i?: number, array?: T[]) => boolean), item: T): void;
    insertAt(at: number, ...item: T[]): void;
    addRange(at: number | T[], arrs?: T[]): void;
    toArray<U>(predict?: (item: T, i?: number, array?: T[]) => U): U[];
    asyncMap<U>(predict?: (item: T, i?: number, array?: T[]) => Promise<U>): Promise<U[]>;
    move(item: T | ((item: T, i?: number, thisArray?: T[]) => boolean), at?: T | number | ((item: T, i?: number, thisArray?: T[]) => boolean)): void;
    append(...item: T[]): void;
    prepend(...item: T[]): void;
    copy(json: any): any;
    findLastIndex(predict: (item: T, i?: number, array?: T[]) => boolean): number;
    clear(): void;
    split(fx: (item: T, i?: number, array?: T[]) => boolean): T[][];
    except<U>(s: U[], fx?: (t: T, u: U) => boolean): T[];
    intersect<U>(s: U[], fx?: (source: U, item: U) => boolean): T[];
    limit(s: number, e: number): T[];
    range(s: number, e: number): T[];
    lookup<U>(s: ((t: T) => U)): Map<U, T[]>;
    distinct<U>(a?: (t: T) => U): U[];
    count(a: any): number;
    findCount(a: any): number;
    sum(predict?: ((t: T) => number)): number | undefined;
    max(predict?: ((t: T) => number)): number | undefined;
    min(predict?: (t: T) => number): number | undefined;
    findMax(predict?: ((t: T) => number)): T;
    findMin(predict?: ((t: T) => number)): T;
    average(predict?: ((t: T) => number)): number;
    avg(predict?: ((t: T) => number) | string): number;
    arrayJsonEach(arrayJsonName: string, fn: (item: T, deep: number, index: number, sort: number, parent: T, thisArray: T[]) => (void | {
        break?: boolean;
        continue?: boolean;
    })): void;
    arrayJsonFind(arrayJsonName: string, fn: (item: T, index?: number, arr?: T[]) => boolean): T;
    arrayJsonMax(arrayJsonName: string, predict: ((t: T) => number) | string): number | undefined;
    arrayJsonMin(arrayJsonName: string, predict: ((t: T) => number) | string): number | undefined;
    arrayJsonFindMax(arrayJsonName: string, predict: ((t: T) => number) | string): T;
    arrayJsonFindMin(arrayJsonName: string, predict: ((t: T) => number) | string): T;
    arrayJsonExists(arrayJsonName: string, predict: (item: T, index?: number, arr?: T[]) => boolean): boolean;
    arrayJsonFindAll(arrayJsonName: string, fn: (item: T, index?: number, arr?: T[]) => boolean): T[];
    arrayJsonRemove(arrayJsonName: string, fn: T | ((item: T, index?: number, arr?: T[]) => boolean)): void;
    arrayJsonRemoveAll(arrayJsonName: string, fn: (item: T, index?: number, arr?: T[]) => boolean): void;
    arrayJsonToArray(arrayJsonName: string, fn: (item: T, index?: number, arr?: T[]) => any, toArrayJsonName?: string): void;
    arrayJsonClosest(arrayJsonName: string, item: any, fn: any): void;
}
